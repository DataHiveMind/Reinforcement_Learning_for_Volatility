{
  "RL Environment Class": {
    "prefix": "rlenv",
    "body": [
      "import gymnasium as gym",
      "import numpy as np",
      "from gymnasium import spaces",
      "",
      "",
      "class ${1:CustomEnv}(gym.Env):",
      "    \"\"\"${2:Custom RL Environment}\"\"\"",
      "",
      "    metadata = {'render_modes': ['human']}",
      "",
      "    def __init__(self, config: dict):",
      "        super().__init__()",
      "        self.config = config",
      "",
      "        # Define action and observation space",
      "        self.action_space = spaces.Box(",
      "            low=${3:-1.0}, high=${4:1.0}, shape=(${5:5},), dtype=np.float32",
      "        )",
      "        self.observation_space = spaces.Box(",
      "            low=-np.inf, high=np.inf, shape=(${6:100},), dtype=np.float32",
      "        )",
      "",
      "    def reset(self, seed=None, options=None):",
      "        super().reset(seed=seed)",
      "        ${7:# Reset environment state}",
      "        observation = ${8:np.zeros(self.observation_space.shape)}",
      "        info = {}",
      "        return observation, info",
      "",
      "    def step(self, action):",
      "        ${9:# Execute action}",
      "        observation = ${10:np.zeros(self.observation_space.shape)}",
      "        reward = ${11:0.0}",
      "        terminated = ${12:False}",
      "        truncated = ${13:False}",
      "        info = {}",
      "        return observation, reward, terminated, truncated, info",
      "",
      "    def render(self):",
      "        pass",
      "",
      "    def close(self):",
      "        pass",
      "$0"
    ],
    "description": "Create a custom Gymnasium RL environment"
  },
  "PyTorch Lightning Module": {
    "prefix": "plmodule",
    "body": [
      "import pytorch_lightning as pl",
      "import torch",
      "import torch.nn as nn",
      "import torch.nn.functional as F",
      "",
      "",
      "class ${1:LightningModule}(pl.LightningModule):",
      "    \"\"\"${2:PyTorch Lightning Module}\"\"\"",
      "",
      "    def __init__(self, config: dict):",
      "        super().__init__()",
      "        self.save_hyperparameters()",
      "        self.config = config",
      "",
      "        # Define model",
      "        ${3:self.model = nn.Sequential()}",
      "",
      "    def forward(self, x):",
      "        return self.model(x)",
      "",
      "    def training_step(self, batch, batch_idx):",
      "        x, y = batch",
      "        y_hat = self(x)",
      "        loss = F.mse_loss(y_hat, y)",
      "        self.log('train_loss', loss)",
      "        return loss",
      "",
      "    def validation_step(self, batch, batch_idx):",
      "        x, y = batch",
      "        y_hat = self(x)",
      "        loss = F.mse_loss(y_hat, y)",
      "        self.log('val_loss', loss)",
      "        return loss",
      "",
      "    def configure_optimizers(self):",
      "        optimizer = torch.optim.Adam(self.parameters(), lr=${4:1e-3})",
      "        return optimizer",
      "$0"
    ],
    "description": "Create a PyTorch Lightning module"
  },
  "Test Function": {
    "prefix": "testfunc",
    "body": [
      "def test_${1:function_name}():",
      "    \"\"\"${2:Test description}\"\"\"",
      "    # Arrange",
      "    ${3:pass}",
      "",
      "    # Act",
      "    ${4:pass}",
      "",
      "    # Assert",
      "    ${5:assert True}",
      "$0"
    ],
    "description": "Create a pytest test function"
  },
  "MLflow Experiment": {
    "prefix": "mlflowexp",
    "body": [
      "import mlflow",
      "",
      "with mlflow.start_run(run_name=\"${1:experiment_name}\"):",
      "    # Log parameters",
      "    mlflow.log_params({",
      "        ${2:\"param1\": value1,}",
      "    })",
      "",
      "    # Training code",
      "    ${3:pass}",
      "",
      "    # Log metrics",
      "    mlflow.log_metrics({",
      "        ${4:\"metric1\": value1,}",
      "    })",
      "",
      "    # Log model",
      "    mlflow.pytorch.log_model(${5:model}, \"${6:model_name}\")",
      "$0"
    ],
    "description": "Create an MLflow experiment tracking block"
  },
  "Config Parser": {
    "prefix": "configparse",
    "body": [
      "import yaml",
      "from pathlib import Path",
      "from typing import Dict, Any",
      "",
      "",
      "def load_config(config_path: str) -> Dict[str, Any]:",
      "    \"\"\"Load configuration from YAML file.\"\"\"",
      "    with open(config_path, 'r') as f:",
      "        config = yaml.safe_load(f)",
      "    return config",
      "",
      "",
      "config = load_config(\"${1:configs/config.yaml}\")",
      "$0"
    ],
    "description": "Config parser function"
  },
  "Dataclass": {
    "prefix": "dataclass",
    "body": [
      "from dataclasses import dataclass",
      "from typing import ${1:Optional}",
      "",
      "",
      "@dataclass",
      "class ${2:ClassName}:",
      "    \"\"\"${3:Class description}\"\"\"",
      "    ${4:field1}: ${5:str}",
      "    ${6:field2}: ${7:int} = ${8:0}",
      "$0"
    ],
    "description": "Create a Python dataclass"
  },
  "Argparse": {
    "prefix": "argparse",
    "body": [
      "import argparse",
      "",
      "",
      "def parse_args():",
      "    parser = argparse.ArgumentParser(description=\"${1:Script description}\")",
      "    parser.add_argument(",
      "        \"--${2:arg}\",",
      "        type=${3:str},",
      "        default=${4:None},",
      "        help=\"${5:Argument description}\"",
      "    )",
      "    return parser.parse_args()",
      "",
      "",
      "if __name__ == \"__main__\":",
      "    args = parse_args()",
      "    ${6:pass}",
      "$0"
    ],
    "description": "Create argparse argument parser"
  }
}
